package sudoku.command;

import lombok.Getter;
import sudoku.model.Sudoku;
import sudoku.strategy.Resolvable;
import sudoku.strategy.StrategyFactory;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;

/**
 * An invoker that lets the user to choose which strategy is to be used in any state to get the next state.
 * User can return to previous state and even choose new strategy to get to the different state
 */
@Getter
public class ManualInvoker implements Invoker {
//    private static final Logger LOGGER = LoggerFactory.getLogger(ManualInvoker.class);
    private StrategyFactory strategyFactory = new StrategyFactory();
    private List<Command> commands = new LinkedList<>();
//    private List<Step> stepListFromAllUsedMethods = new ArrayList<>();
    private List<Resolvable> strategies = new ArrayList<>();
    private int currentStep = 0;
    private Sudoku sudoku;

    /**
     * Constructor method that gets the current sudoku and sets default strategy
     *
     * @param sudoku    sudoku that is the current sudoku
     */
    public ManualInvoker(Sudoku sudoku) {
        this.sudoku = sudoku;
////         by default only Backtrack Strategy will be used
//        this.strategies.add(new BacktrackLucia());
//      default strategy will be NakedSingleCell
        this.strategies.add(strategyFactory.createNakedSingleInACellStrategy());
    }

    public void setStrategies(Resolvable ... useStrategies) {
        this.strategies = new ArrayList<>();
        this.strategies.addAll(Arrays.asList(useStrategies));
    }

    /**
     * Method that helps navigate between states in backward direction.
     *
     * @return      command containing information about previous state
     */
    @Override
    public Command getPreviousState() {
//        CommandPicker command = null;
        Command command = null;
//        Step step;
//        Resolvable resolvable;
//        Sudoku sudoku;

        if (currentStep > 0) {
//            step = stepListFromAllUsedMethods.get(stepListFromAllUsedMethods.size() - 1);
//            stepListFromAllUsedMethods.remove(stepListFromAllUsedMethods.size() - 1);
            currentStep--;
//            command = commands.remove(commands.size()-1);
            commands.remove(commands.size()-1);
            command = commands.get(commands.size() - 1);
//            resolvable = ((OneChangeStep)step).getResolvable();
//            sudoku = ((OneChangeStep)step).getSudoku();
//            command = new CommandPicker(resolvable, sudoku);
        }
        if (command != null) {
//            LOGGER.info("getPreviousState: current state is " + command.getStepList().get(0).toString());
        }

        return command;
    }

    /**
     * Method that generates a new command containing next state in sequence. Returned Command is generated by applying
     * of the strategy by the user on current state of the sudoku
     *
     * @return      command containing information about next state
     */
    @Override
    public Command getNextState() {

        CommandPicker command = new CommandPicker(strategies.get(0), sudoku);

        if (!sudoku.isSudokuResolved()) {
            sudoku = command.execute();
//            Step oneStep = strategies.get(0).getStepList().get(0);
//            stepListFromAllUsedMethods.add(oneStep);
            currentStep++;
//            command = new CommandPicker(strategies.get(0), ((OneChangeStep) oneStep).getSudoku());
            command = new CommandPicker(strategies.get(0), sudoku.copy());
            commands.add(command);
        }
//        LOGGER.info("getNextState: current state is " + command.getStepList().get(0).toString());

        return command;
    }

    /**
     * Method that directly sets strategy that is to be used to generate next state and then generates command
     * containing the next state
     *
     * @param strategy  resolvable that is strategy chosen by user to be used to get the next state
     * @return          a command containing the next state achieved by using chosen strategy
     */
    public Command getNextState(Resolvable strategy) {
        setStrategies(strategy);

        return getNextState();
    }

//    @Override
//    public Command solvingStepsOrder() {
//        return null;
//    }
}
